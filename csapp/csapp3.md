# 三.程序的机器级表示

### 1.历史观点

### 2.程序编码

### 3.数据格式

### 4.访问信息







#### 	4.1操作数指示符

#### 	4.2数据传输指令







#### 	4.3数据传输实例

复习一下



实例：最简单形式的数据传输指令---MOV类

指令：4条

​		movb  

​		movw

​		movl

​		move

作用:  将数据从一个位置复制到另一个位置

区别：操作的数据大小不同 ， 分别是1， 2， 4， 8 个字节IA32指令集

（Intel 32 位体系结构Intel  Architecture  32-bit）熟称x86



看书上的代码



#### 	4.4压入和弹出栈数据



- 因算数和逻辑操作在汇编层面都是都内存，寄存器，和立即数的操作，（还有一个栈的概念）

所以我们要先理解三者的位置和关系

书上第6，7页也有图





这里的汇编基于

<img src="/Users/zhangkuang/Desktop/截屏2021-04-09 下午9.29.06.png" style="zoom:25%;" />





![截屏2021-04-04 下午2.57.22](/Users/zhangkuang/Desktop/截屏2021-04-04 下午2.57.22.png)



![截屏2021-04-04 下午2.03.06](/Users/zhangkuang/Desktop/截屏2021-04-04 下午2.03.06.png)

​	



栈是什么？

栈是内存中属于某个函数的一段连续的空间



一个程序在运行时，这些局部变量会会存储在内存中的区域，称为 栈 

<img src="/Users/zhangkuang/Desktop/截屏2021-04-09 下午9.29.39.png" alt="截屏2021-04-09 下午9.29.39" style="zoom:25%;" />

![截屏2021-04-09 下午9.30.30](/Users/zhangkuang/Desktop/截屏2021-04-09 下午9.30.30.png)

栈是一种基本的数据结构，只有两个操作，一个是push入栈，另一个是pop出栈



pushq是将数据压到栈上

popq是将弹出 数据

但在内存中，栈是倒过来的，也就是从高地址向低地址增长

这样栈顶的指针称为栈指针，指向栈的最下面，这里用寄存器%esp（stack pointer）



解释书上的代码



<img src="/Users/zhangkuang/Desktop/截屏2021-04-09 下午9.27.58.png" alt="截屏2021-04-09 下午9.27.58" style="zoom: 25%;" />

<img src="/Users/zhangkuang/Desktop/截屏2021-04-09 下午9.27.04.png" alt="截屏2021-04-09 下午9.27.04" style="zoom:33%;" />





![截屏2021-04-09 下午9.55.00](/Users/zhangkuang/Desktop/截屏2021-04-09 下午9.55.00.png)





帧指针用来标志一段程序的开始

一个函数运行前会先创建好栈帧，主函数对应的栈帧的起始地址用帧指针%ebp保存

栈指针和帧指针操作函数（程序）的进行



### 5.算数和逻辑操作

对数据的指令





![截屏2021-04-04 下午5.01.23](/Users/zhangkuang/Desktop/截屏2021-04-04 下午5.01.23.png)



![截屏2021-04-04 下午5.01.41](/Users/zhangkuang/Desktop/截屏2021-04-04 下午5.01.41.png)





操作：一共有四组



![截屏2021-04-08 下午9.45.36](/Users/zhangkuang/Desktop/截屏2021-04-08 下午9.45.36.png)





#### 	5.1加载有效地址

​			leap指令：它的指令形式是从内存读取数据到寄存器，但实际上它根本没有引用内存。它的第一个操作数看上去是一个内存引用，但该指令并不是从指定的位置读入数据，而是将有效地址写入到目的操作数。

##### 源操作数            目的操作数

   	内存		   ｜	 必须是一个寄存器





#### 	5.2一元和二元操作

​			一元操作：一个操作数，既是源操作数，又是目的操作数。可以是一个寄存器，也可以是一个内存位置。

C语言：加1运算符（++）和 减1运算符（——）

​			二元操作：第二个操作数既是  源  又是   目的  操作数，

C语言：赋值运算符 （x += y）



源操作数                   目的操作数

```
立即数				｜      寄存器

寄存器						  内存位置

内存位置
```







#### 	5.3移位操作

移位操作：第一项给出移位量，第二项给出要移位的数。移位量可以是一个立即数，也可以放在单字节寄存器  %cl  中



C语言：移位运算符（>>和<<）



```
源操作数     ｜       目的操作数

立即数				|		  寄存器

寄存器							内存位置


```





#### 	5.4讨论

无符号和有符号？？？

书上给了一段代码



#### 	5.5特殊的算数操作	（128位乘积以及整数除法）



imulq指令有两种不同的形式（）双胞胎

​	1.图3-10中IMUL指令类中一中双操作数

​	2.  2条单操作数乘法指令

​			1）无符号数乘法（mulq）

​			2）补码乘法（imulq）



~~有符号无符号好烦~~



除法

```
被除数  /   除数    =   商  。。。。 余数

被除数：idivl指令从%rdx中取出
除数：作为指令的操作数给出
商：放到%rax中
余数：放在%rdx中
```







### 6.控制

### 7.过程

### 8.数组分配和访问

### 9.异质的数据结构

### 10.在机器级程序中将程序和控制结合起来

### 11.浮点代码

### 12.小结